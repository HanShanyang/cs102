// package whatever; // don't place package name!

import java.io.*;
import java.util.*;
/*
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
For example,
Given [3,2,1,5,6,4,6] and k = 2, return 5.
[3,2,1,5,6,4,6]
[2,1,3,5,6,4,6] k = 2 5
[2,1] [5,6,4,6] k = k - 
Note: 
You may assume k is always valid, 1 ≤ k ≤ array's length.
*/
class MyCode {
  public static void main (String[] args) {
    System.out.println("Hello Java");
    int[] nums = {3,2,1,5,6,4, 6};
    int k = 2;
    int res = findKthLargest(nums, k);
    System.out.println(res);
    
    
    int[] array = {1,3,-1,-3,5,3,6,7};
    List<Integer> result = maxSlidingWindow(array, 3);
    System.out.println(result);
    
    String [] dict = {
      "wrta",
      "wrfb",
      "er",
      "ett",
      "rftt"      
    };
    
    String resString = alienDict(dict);
    
    System.out.println(resString);
  }
  
  
  public static int findKthLargest(int[] nums, int k) {
    // corner case
    if (nums == null || nums.length < k) {
      return -1;
    }
    
    PriorityQueue<Integer> minHeap = new PriorityQueue<>(k, (a, b)-> a - b);
    // 
    for (int i = 0; i < nums.length; ++ i) {
      if (minHeap.size()  < k) {
        minHeap.offer(nums[i]);
      } else {
        if (minHeap.peek() < nums[i]) {
          minHeap.poll();
          minHeap.offer(nums[i]);
        } 
      }
    }
    return minHeap.peek();
  }
  
//   public static int findKthLargestII(int[] nums, int k) {
//       // corner case
//       // Done
//       int res = quickSelect(nums, 0, nums.length - 1, k);
//       return res;
//   }
  
//   private static int quickSelect(int[] nums, int left, int right, int k) {
//       int pivot = nums[left];
//       int l = left, r = right;
//       int i = left;
//       // 
//       while (i < right) {
//         if (nums[i] < pivot) {
//           swap(nums, i, l);
//           ++ left;
//           ++ i;
//         } 
//         if (nums[r] > pivot) {
//           ++ i;
//         }
//       }
//   }
  
  Random rand = new Random();
    public int findKthLargest(int[] nums, int k) {
        return quickSort(nums, 0, nums.length - 1, k);
    }
    
    public int quickSort(int[] nums, int start, int end, int k) {
        int par = partition(nums, start, end);
        if (par == k - 1)
            return nums[par];
        if (par > k - 1) {
            return quickSort(nums, start, par - 1, k);
        }
        
        return quickSort(nums, par + 1, end, k);
    }
    
    public int partition(int[] nums, int start, int end) {
        int idx = rand.nextInt(end - start + 1) + start;
        int pivot = nums[idx];
        swap(nums, idx, end);
        int par = start;
        int par2 = end;
        for (int i = start; i < end; i++) {
            if (nums[i] > pivot) {
                swap(nums, par, i);
                par++;
            }
        }
        swap(nums, par, end);
        return par;
    }
    
    public void swap(int[] nums, int i, int j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
  
  
  
  static Deque<Integer> deque = new ArrayDeque<>();
  static List<Integer> maxResult = new ArrayList();
  public static List<Integer> maxSlidingWindow(int[] nums, int k) {
    // corner
    if (nums == null || nums.length < k) {
      return maxResult;
    }
    
    // init
    for (int i = 0; i < k; ++ i) {
      add(nums, i);
    }
    maxResult.add(nums[deque.peekFirst()]);
    
    for (int i = k; i < nums.length; ++ i) {
      remove(nums, i, k);
      add(nums, i);
      maxResult.add(nums[deque.peekFirst()]);
    }
    return maxResult;
    
  }
  
  public static void remove(int[] nums, int i, int k) {
    if (!deque.isEmpty() && deque.peek() == i - k) {
      deque.pollFirst();
    }
  }
  
  public static void add(int[] nums, int i) {
    while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
      deque.pollLast();
    }
    deque.offerLast(i);
  }
  
  
  //   Best Time to Buy and Sell Stock
  //   Input: [7, 1, 5, 3, 6, 4]
  //   Output: 5
  //   [7,1,5 ....]
  //   [7,1,1,1,1,1,1]
  //   [7,6,6,6,6,4]
//   public static int maxProfit(int[] prices) {
//     int n = prices.length;
//     int min = Integer.MAX_VALUE;
//     int max = 0;
    
//     res = 0;
//     for (int i = 0; mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmi < n ; i++) {
//       res = Math.max(res, prices[i] - min);
//       min = Math.min(min, prices[i]);
//     }
    
//     return res;
//   }
  
  
  public static String alienDict(String[] strs) {
    int[] indegree = new int[26];
    Arrays.fill(indegree, -1);
    Map<Character, List<Character>> map = new HashMap<>();
    
    for (int i = 0; i < strs.length - 1; i++) {
      char[] s1 = strs[i].toCharArray();
      char[] s2 = strs[i + 1].toCharArray();
      
      int l = Math.min(s1.length, s2.length);
      for (int j = 0; j < l; j++) {
        if (s1[j] != s2[j]) {
          if (indegree[s2[j] - 'a'] == -1) {
            indegree[s2[j] - 'a'] = 0;
          }
          indegree[s2[j] - 'a'] ++;
          if (indegree[s1[j] - 'a'] == -1) {
            indegree[s1[j] - 'a'] = 0;
          }
          
          map.putIfAbsent(s1[j], new ArrayList<>());
          map.get(s1[j]).add(s2[j]);
          break;
        }
      }
    }
    
    
    Queue<Character> queue = new LinkedList<>();
    
    for (int i = 0; i < 26; i++) {
      if (indegree[i] == 0) {
        queue.offer((char) ('a' + i));
      }
    }
    
    StringBuilder sb = new StringBuilder();
    while (!queue.isEmpty()) {
      int size = queue.size();
      
      for (int i = 0; i < size; i++) {
        char c = queue.poll();
        sb.append(c);
        List<Character> next = map.get(c);
        if (next != null) {
          for (Character nc: next) {
            indegree[nc - 'a']--;
            if (indegree[nc - 'a'] == 0) {
              queue.offer(nc);
            }
          }
        }
      }
    }
    
    return sb.toString();
  }
}

// minHeap 
// SGiven an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.

// For example,
// Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

// Window position                Max
// ---------------               -----
// [1  3  -1] -3  5  3  6  7       3
//  1 [3  -1  -3] 5  3  6  7       3
//  1  3 [-1  -3  5] 3  6  7       5
//  1  3  -1 [-3  5  3] 6  7       5
//  1  3  -1  -3 [5  3  6] 7       6
//  1  3  -1  -3  5 [3  6  7]      7
// Therefore, return the max sliding window as [3,3,5,5,6,7].

// Note: 
// You may assume k is always valid, ie: 1 ≤ k ≤ input array's size for non-empty array. O()
  
//  4
//   5

// O (n ^ 2)
//  a b a b c 
// c
// b
// a
// b
// indexOf
// abcde  bcd = b * 31 ^ 2 + c * 31 ^ 1 + d * 31 ^ 0

// use Hash to point from source to destination
// [
//   "wrta",
//   "wrfb",
//   "er",
//   "ett",
//   "rftt"
// ]

// "we
  
// t -> f
// w -> e
// r -> t
// e -> r 
  
// # step 1
// [t, f, w, e, r] 

// t -> [f]
// f -> []
// w -> [e]
// e -> [r]
// r -> [t]
// a -> [] 
// b -> []

// t -> f -> null
// 'wertf'

  
// compare two consecutive string, find the diff

  



